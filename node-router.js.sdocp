sdocp('node-router.js.sdoc', 'Node router | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nIntroduction.\nThis router is a general-purpose HTTP request router useful for rewriting based on URLs. Unlike node-dispatch (http://github.com/spencertipping/node-dispatch), node-router supports somewhat\ncomplex rewriting such rules such as "route requests to /foo/... to http://some-server/foo/bar/...", or "route requests to /bif/... to file:///home/whoever/files/bif/". In particular, this\nshould be useful for rapid testing/deployment of applications, and maybe ad-hoc file serving.\n\n  caterwaul.clone(\'std\')(function (require) {\n\n  Configuration.\n  This system is relatively straightforward to configure. The configuration language looks just like the one for node-dispatch, but has some extra options in it. The idea is always the same:\n  you specify the beginning of each URL and then what to do with it, and the router preserves any part of the URL that isn\'t matched by the pattern and tacks it onto the end. (In other words,\n  you always have exactly one wildcard, and it is on the end of the URL.)\n\n  Here are the directives that are supported:\n\n  | /bar goes to file:///some/directory\n    /bif/baz goes to port 8082\n    /foo goes to http://server/foo\n\n  If you\'re serving from a directory, it serves index.html if there is one. Note that this is not, in general, a secure server for files; I\'m sure there are ways to get it to read arbitrary\n  files from the filesystem. The only reason I\'ve got file routing at all is because it\'s useful for prototyping applications without deploying them.\n\nServer components.\nNothing much here, just a routing table and a loop to watch the route file. Then there\'s a simple file server that strips out repeated dots, the most obvious way that a user could try to hack\nthe server. The HTTP server just forwards requests along, copying the headers, body, and everything else. (Only the \'host\' header is changed; this avoids confusing virtual-host setups.)\n\n  Route file parsing.\n  This is just like node-dispatch but with a few more variations. Fortunately we don\'t need to detect the URL type here; we can just store the destination as a valid URL-formatted string and\n  unify that logic in the router itself.\n\n    var routing_table = [];\n    let[parse_routing_table = fn_[require(\'fs\').readFile(routing_file), fn[data][\n      routing_table = {},\n      data.split(/\\n+/).map(fn[s][s.replace(/#.*$|^\\s+/g, \'\')]).filter(fn[s][s.length]).map(fn[s][s.split(/\\s*goes to\\s*/)]).\n                    forEach(fn[parts][routing_table.push({url: parts[0], route: /^port\\s/.test(parts[1]) ? \'http://localhost:#{parts[1].replace(/^port\\s+/, "")}/\' : parts[1]})])]]] in\n\n    (parse_routing_table(),\n     require(\'fs\').watchFile(routing_file, parse_routing_table)), where[routing_file = process.argv[2]];\n\n  URL delegation.\n  Each URL scheme has its own handler, stored in this global table:\n\n    const url_handlers = {\n\n    File serving.\n    Files are basically served straight, but no up-navigation is allowed. That is, any multiple-dot sequences in the path are replaced by just one dot, which is a (vulnerable, I\'m sure)\n    attempt to remove obvious security holes. Also, all file requests are treated as reads, even if they\'re PUT, POST, or DELETE. I\'m sure this will cause weird problems, but that\'s how I\'m\n    doing it for now.\n\n    There\'s also a basic MIME table, nothing too fancy. It assigns MIME types to HTML, JavaScript, and CSS files. Everything else is sent down as text/html.\n\n      file: (fn[req, res, relative_url, route_url][require(\'fs\').readFile(\'#{route_url.replace(/^file:\\/\\//, "")}/#{relative_url.replace(/\\.\\+/g, "")}\',\n                                                   fn[err, data][err ? (res.writeHead(500), res.end(err)) : (res.writeHead(200, {\'content-type\': content_type_for(relative_url)}),\n                                                                                                             res.end(data))])],\n             where[content_type_for = fn[filename][/\\.js$/i.test(filename) ? \'application/javascript\' : /\\.css$/i.test(filename) ? \'test/css\' : \'text/html\']]),\n\n    HTTP serving.\n    This is a little harder, as data and headers need to be forwarded and chunking needs to be done for both the upload and the download. This involves parsing out the http:// URL (including a\n    potential port specification), creating a new \'host\' header, and pipelining each end. (So more than a one-liner, basically.)\n\n      http: fn[req, res, relative_url, route_url][let[headers = caterwaul.util.merge({}, req.headers, {host: host})] in\n                                                  (let[req0 = require(\'http\').createClient(port || 80, host).request(req.method, url, headers)] in\n                                                   (req0.on(\'response\', fn[res0][res0.setEncoding(\'binary\'),\n                                                                                 res.writeHead(res0.responseCode, res0.headers),\n                                                                                 res0.on(\'data\', fn[data][res.write(data, \'binary\')]),\n                                                                                 res0.on(\'end\',  fn_[res.end()])]),\n                                                    req.on(\'data\', fn[data][req0.write(data, \'binary\')]),\n                                                    req.on(\'end\',  fn_[req0.end()]))),\n                                                  where[host = parts[0], port = parts[1], url = parts[2]],\n                                                  where[parts = /^http:\\/\\/([^:\\/]+)(:?\\d*)(\\/.*)$/.exec(\'#{route_url}/#{relative_url}\')]]};\n\n  Top-level routing.\n  Each toplevel request is matched against the table. The first matching rule is used.\n\n    process.on(\'uncaughtException\', fn[e][console.log(e)]);\n    require(\'http\').createServer(function (req, res) {for (var i = 0, l = routing_table.length, r; r = routing_table[i], i < l; ++i) if (req.url.substring(0, r.url.length) === r.url) break;\n                                                      i < l ? let[handler = url_handlers[r.route.substring(0, 4)], relative_url = req.url.substring(r.url.length)] in\n                                                              (handler ? handler(req, res, relative_url, r.url) : error(\'Invalid protocol: #{r.route.substring(0, 4)}\'))\n                                                            : error(\'Unrouted URL: #{req.url}\'), where[error = fn[reason][res.writeHead(500), res.end(reason)]]}).listen(8080, \'0.0.0.0\');\n  })(require);\n');